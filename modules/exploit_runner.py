"""
Exploit Runner Module for C-Keeper
Executes exploits against targets
"""

import subprocess
import threading
import tempfile
import os
from datetime import datetime
from typing import Dict, Any, List

from core.logger import CKeeperLogger

class ExploitRunnerModule:
    """Exploit execution module"""
    
    def __init__(self, config, database):
        self.config = config
        self.db = database
        self.logger = CKeeperLogger(__name__)
        self.running_exploits = {}
    
    def execute_exploits(self, target: str, delivery_data: Dict[str, Any]) -> Dict[str, Any]:
        """Execute exploits against target"""
        return {
            'target': target,
            'exploits_executed': 1,
            'successful': 0,
            'failed': 1,
            'results': []
        }
    
    def run_exploit(self, exploit: Dict[str, Any], target: str = None) -> Dict[str, Any]:
        """Run single exploit"""
        execution_id = f"exec_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{os.urandom(4).hex()}"
        
        result = {
            'execution_id': execution_id,
            'exploit_id': exploit.get('id', 'unknown'),
            'target': target or exploit.get('target', 'unknown'),
            'timestamp': datetime.now().isoformat(),
            'success': False,
            'output': '',
            'errors': [],
            'duration': 0
        }
        
        try:
            start_time = datetime.now()
            
            # Create temporary file for exploit
            with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
                f.write(exploit['code'])
                temp_file = f.name
            
            # Execute exploit
            process = subprocess.run(
                ['python', temp_file],
                capture_output=True,
                text=True,
                timeout=self.config.timeout
            )
            
            result['output'] = process.stdout
            result['success'] = process.returncode == 0
            
            if process.stderr:
                result['errors'].append(process.stderr)
            
            # Calculate duration
            duration = (datetime.now() - start_time).total_seconds()
            result['duration'] = duration
            
            # Cleanup
            os.unlink(temp_file)
            
            self.logger.log_operation(
                'EXPLOIT_EXECUTED', result['target'], 
                'SUCCESS' if result['success'] else 'FAILED',
                exploit_id=exploit.get('id', 'unknown'),
                duration=duration
            )
            
        except subprocess.TimeoutExpired:
            result['errors'].append('Exploit execution timed out')
            self.logger.logger.warning(f"Exploit {execution_id} timed out")
        except Exception as e:
            result['errors'].append(f'Execution error: {e}')
            self.logger.logger.error(f"Exploit execution error: {e}")
        
        return result
    
    def run_exploit_async(self, exploit: Dict[str, Any], target: str = None) -> str:
        """Run exploit asynchronously"""
        execution_id = f"async_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{os.urandom(4).hex()}"
        
        thread = threading.Thread(
            target=self._async_exploit_runner,
            args=(execution_id, exploit, target)
        )
        thread.daemon = True
        thread.start()
        
        self.running_exploits[execution_id] = {
            'thread': thread,
            'status': 'running',
            'started_at': datetime.now().isoformat()
        }
        
        return execution_id
    
    def _async_exploit_runner(self, execution_id: str, exploit: Dict[str, Any], target: str):
        """Async exploit runner"""
        try:
            result = self.run_exploit(exploit, target)
            self.running_exploits[execution_id]['status'] = 'completed'
            self.running_exploits[execution_id]['result'] = result
        except Exception as e:
            self.running_exploits[execution_id]['status'] = 'failed'
            self.running_exploits[execution_id]['error'] = str(e)
    
    def get_execution_status(self, execution_id: str) -> Dict[str, Any]:
        """Get status of async execution"""
        if execution_id not in self.running_exploits:
            return {'error': 'Execution not found'}
        
        return self.running_exploits[execution_id]
    
    def stop_execution(self, execution_id: str) -> bool:
        """Stop running execution"""
        if execution_id not in self.running_exploits:
            return False
        
        try:
            # Note: This is a simplified implementation
            # Real implementation would need proper process management
            self.running_exploits[execution_id]['status'] = 'stopped'
            return True
        except:
            return False
    
    def list_executions(self) -> List[Dict[str, Any]]:
        """List all executions"""
        return [
            {
                'execution_id': exec_id,
                'status': data['status'],
                'started_at': data['started_at']
            }
            for exec_id, data in self.running_exploits.items()
        ]
